Manage "incubator" for connections that have not yet been transferred to a locker. Create an incubator directory at the same level of the lockers; put inside the connections that are waiting for a locker to be created, manage the aspect that when they are transferred to a locker, "inmsg" creates the files again... To be avoided in this case, just move the dir from a place to the other if possible.

Go on with VFS implementation: create content in directories "holders" and "waitings";

If a process is inside the dir mounted by FUSE, the umount does not work and the flom daemon does not end...

Remove all warnings for Ubuntu 14.04; more recent ones can happen

Clean-up code of VFS, remove all garbage, use FLoM style everywhere




Possible ideas for future developments, if useful: 

implement stack trace feature as implemented by LIXA project

introduce a supplementary module build for Perl and Python to avoid installation before "make check" (verify other bindings like Java too...)

implement a loop for connect/bind if bind returns an error: this should help
to reduce the race condition between a closing daemon and a starting client.
See this thread: https://github.com/tiian/flom/issues/3

Other ideas.....

"object" resources with a state, a memory area, managed by FLoM to transform it in a "state manager" other than a "lock manager"; for flom client, the object will be dumped/restored to/from file

"vector" resources with an associative array of memory areas, managed by FLoM (evolution of "object"; for flom client, the vector will be dumped/restored to/from a zip file or a directory

RESTful interface implemented using Mongoose (?)

replace poll custom based implementation with libevent... (is it interesting?)

put inside function flom_accept_loop_chklockers a check if the thread associated to the locker is really active; if the thread leaved (due to an error), make a clean-up phase. This avoid a daemon crash after a thread terminated with an error, but listener thread has a "locker object" already active

implement FIFO, LIFO, FIRST FIT (for numerical resources) lock allocation policies
