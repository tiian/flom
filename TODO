How to manage incubating connections:
1. when they are put in the "incubator" (flom_accept_loop_transfer L1733 flom_conn_set_wait(conn, TRUE)
2. create a folder with the UID of the connection under dir "incubator"
3. inside the folder put 3 files: peer_name, resource_name, resource_type
4. when they exit from the "incubator" (flom_accept_loop_transfer L1797, moved to the locker with flom_accept_loop_transfer_conn)
5. get rid of the folder created below "incubator", it will be re-created inside "waitings" and then moved to "holders"

If a process is inside the dir mounted by FUSE, the umount does not work and the flom daemon does not end...

Remove all warnings for Ubuntu 14.04; more recent ones can happen

Clean-up code of VFS, remove all garbage, use FLoM style everywhere




Possible ideas for future developments, if useful: 

implement stack trace feature as implemented by LIXA project

introduce a supplementary module build for Perl and Python to avoid installation before "make check" (verify other bindings like Java too...)

implement a loop for connect/bind if bind returns an error: this should help
to reduce the race condition between a closing daemon and a starting client.
See this thread: https://github.com/tiian/flom/issues/3

Other ideas.....

"object" resources with a state, a memory area, managed by FLoM to transform it in a "state manager" other than a "lock manager"; for flom client, the object will be dumped/restored to/from file

"vector" resources with an associative array of memory areas, managed by FLoM (evolution of "object"; for flom client, the vector will be dumped/restored to/from a zip file or a directory

RESTful interface implemented using Mongoose (?)

replace poll custom based implementation with libevent... (is it interesting?)

put inside function flom_accept_loop_chklockers a check if the thread associated to the locker is really active; if the thread leaved (due to an error), make a clean-up phase. This avoid a daemon crash after a thread terminated with an error, but listener thread has a "locker object" already active

implement FIFO, LIFO, FIRST FIT (for numerical resources) lock allocation policies
